### C와 파이썬 배열 비교

C 배열 : 크기가 고정, 같은 타입의 데이터만 저장 가능, 값이 메모리에 연속적으로, 순서대로 저장

ex) int numArray[4];

파이썬 리스트 : 메모리가 연속적으로 저장되지 않을 수 있음, 값이 아닌 레퍼런스를 저장함. 다양한 타입의 데이터를 저장 가능.

즉 파이썬은 할당된 공간에 레퍼런스를 저장하기 때문에 실제 값이 저장되는 공간이 따로 또 있어 C보다 메모리를 더 사용한다. 파이썬 리스트는 크기 변화에 대비하기 위해 실제로 사용하는 메모리보다 더 많은 메모리를 미리 할당하기도 해서 그 이상의 메모리를 사용함.

배열 인덱스 접근: O(1), 인덱스를 명확히 알고 있으면 추가 탐색 필요없이 바로 값을 꺼낼 수 있기 때문!

배열 탐색 연산: O(n)

### 배열 접근, 탐색

배열에 접근할 때는 인덱스를 이용한다.

인덱스 주소 = 시작 주소 + 데이터 크기 * 인덱스

로 계산된다.

배열을 탐색할 때 선형 탐색을 한다고 하면 시간 복잡도는 O(n) 이다.

### 정적 배열, 동적 배열

정적 배열의 경우 크기가 고정되고, 요소의 수가 제한된 배열이다. → 배열을 얘기할 때 기본 내용

동적 배열(Dynamic Array)은 크기가 고정되어 있지 않고 계속 추가가 가능한 배열이다. 정적 배열을 기반으로 실제 내부적으로는 공간이 부족하면 기존 배열보다 2배(예를 들어)의 크기의 배열을 만들고 기존 값을 복사한 뒤 뒤에 추가하는 식으로 동작한다.  

파이썬의 리스트는 동적 배열의 대표적인 예시다. 데이터를 추가 혹은 삭제할 때 그에 맞춰서 파이썬에서는 인덱스 범위를 따로 관리한다. 

예를 들어, 한 개의 값을 삭제하면 내부적으로 접근할 수 있는 인덱스 범위가 줄어든다. 실제 내부적으로 메모리에 값이 남아있으나 접근할 수 없게 된다.

정적 배열은 삽입 연산, 삭제 연산이 불가능하다. 

정적 배열은 낭비공간이 없는 반면, 동적 배열은 낭비를 할 수도, 안할 수도 있다.

### 삽입 연산 append operation : 배열의 끝에 값을 추가

여유 공간이 있는 경우 O(1)

여유 공간이 없다면 O(n)

기존 배열의 *2의 배열을 만듬 + 기존 데이터 복사 + 새로운 값 추가

새로운 데이터를 복사해 저장하는데에 n의 시간, 

옮기고 저장하는 데에는 2n보다 시간이 적게 걸린다.(2m-1)

→ 합치면 3n보다 적게 걸리고 결국 O(n)

근데 이건 추가 연산을 연속으로 n번 한다는 가정이고 1번하면 결국 O(1)

근데 보통 삽입 연산의 케이스에 여유 공간이 많은 경우가 더 많다. 알고리즘은 보통 보수적으로 최악의 케이스를 가정하는데 이 경우 분할 상환(Amortized Anaylsis) 분석을 사용하면 O(1)이 된다.

분할 상환은 같은 동작은 n번 했을 때 드는 시간이 X일 때, 동작을 1번하는데 걸린 시간을 계산한다.

X/n

보통 이렇게 현실과 좀 다른 결과가 나오는 케이스는 분할 상환 방식으로 시간 복잡도를 계산하기도 한다. 물론 꼭 분할 상환을 적용하는게 올바르진 않다.

**정리**

동적 배열의 추가 연산은 최악의 경우 O(n), 분할 상환 분석을 하면 O(1)이 걸린다.

### insert operation(삽입 연산)

공간이 있다면 O(n) + O(1) = O(n)

공간이 없다면 O(2n+1) → O(n)

### delete operation(삭제 연산)

최고 - O(1)(가장 뒤에 있다면)

최악 - O(n)

동적 배열의 크기 줄이기 → 내부 배열의 사용 비율이 특정 값 이하로 떨어지면, 새로운 배열을 정의하고 + 기존 배열 값을 옮겨서 저장한다.

→ O(n), 분할상환시 O(1)