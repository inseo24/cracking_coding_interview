## 복잡도(Complexity)

알고리즘의 성능을 나타내는 척도
- 시간 복잡도 : 알고리즘을 위해 필요한 연산의 횟수
- 공간 복잡도 : 알고리즘을 위해 필요한 메모리의 양

(정확한 정의를 위해서는 계산 복잡도 이론 공부를 추천)

시간 복잡도와 공간 복잡도는 tradeoff 관계가 성립


### 시간 복잡도
보통 알고리즘에서 말하는 복잡도가 시간 복잡도를 의미
Big O 표기법을 사용해 표현한다.
Big O는 가장 빠르게 증가하는 항만을 고려하는 표기법이다. 함수의 상한만을 나타낸다.


| 빅오 표기법            |  명칭                |   
|:---: | :---: |
| O(1)         |  상수 시간(Constant time)         |   
| O(logN)       |      로그 시간(log time)     |
| O(N) | 선형 시간 |
| O(NlogN) | 로그 선형 시간 |
| O(N<sup>2</sup>) | 이차 시간 |
| O(N<sup>3</sup>) | 삼차 시간|
| O(2<sup>N</sup>) | 지수 시간 |


일반적인 코딩 테스트 환경에서 O(N<sup>3</sup>)을 넘어가면 문제 풀이에 사용하기 어렵다.
연산 횟수가 10억을 넘어갈 경우 오답 판정을 받을 수 있다.

| 빅오 표기법            |  N이 1,000일 때 연산 횟수         |   
|:---: | :---: |
| O(N) | 1000 |
| O(NlogN) | 10,000 |
| O(N<sup>2</sup>) | 1,000,000 |
| O(N<sup>3</sup>) | 1,000,000,000 |


고로 시간 복잡도 분석은 문제 풀이의 핵심이다. 
알고리즘에 능숙해지면 문제 풀기 전에 조건을 먼저 보기도 하는데, 문제의 조건부터 확인하면 얼마나 효율적인 알고리즘을 짜야하는지 감을 잡을 수 있기 때문이다.
예를 들어, 데이터의 개수 N이 1,000만 개를 넘어가며 시간 제한이 1초라면, 대략 최악의 경우 O(N)의 시간 복잡도로 동작하는 알고리짐을 작성해야 할 것으로 예상할 수 있다. 

일반적으로 문제를 풀 때의 예시를 소개한다. 아래의 예시는 모두 시간 제한이 1초인 문제에 대한 예시다.
- N의 범위과 500인 경우: 시간 복잡도가 O(N<sup>3</sup>)인 알고리즘을 설계하면 문제 풀이 가능
- N의 범위가 2,000인 경우: O(N<sup>2</sup>)인 알고리즘
- N의 범위가 100,000인 경우: O(NlogN)
- N의 범위가 10,000,000dls ruddn: O(N)


### 공간 복잡도
공간 복잡도를 표기할 때도 빅오 표기법을 이용한다.
일반적인 메모리 사용량 기준은 MB 단위로 제시된다. 
예를 들어, 시간 제한 1초, 메모리 제한 128MB 와 같은 문장으로 시간 복잡도와 공간 복잡도를 함께 제한하기 위해 명시한다.

대부분의 코딩 테스트 문제는 리스트(배열)을 사용해서 풀어야 한다. 다수의 데이터에 대한 효율적인 처리를 요구하기 때문이다. 
int를 기준으로 리스트 크기에 따른 메모리 사용량을 확인해보자
- int a[1000]: 4KB
- int a[1000000]: 4MB
- int a[2000][2000]: 16MB

보통 메모리 사용량을 128~512MB 로 제한하므로 일반적으로 데이터 개수가 1,000만 단위가 넘어가지 않도록 알고리즘을 설계해야 한다. 


### 시간과 메모리 측정
알고리즘을 공부하는 과정에서 시간을 측정하는 작업을 굉장히 많이 사용한다. 실질적으로 알고리즘의 소요 시간을 확인해야 제대로 작성한 지 체크할 수 있기 때문이다.
다시 말해 실제 프로그램의 수행 시간을 측정하는 것은 알고리즘 효율성을 측정하는 가장 기본적인 방법이다. 
특정한 프로그램의 수행 시간을 측정하는 소스 코드는 다음과 같다.

```python

import time
start_time = time.time() # 측정시간

# 프로그램 소스 코드
end_time = time.time() # 측정 종료
print("time :", end_time - start_time) # 수행 시간 출력
```

위의 코드는 어떤 알고리즘을 설계한 뒤에 시간 복잡도를 경험적으로 증명하고 싶을 때 자주 이용한다.
예를 들어, 선택 정렬과 파이썬의 기본 정렬 라이브러리의 속도를 비교할 때는 다음과 같이 소스 코드를 작성할 수 있다. 선택 정렬을 사용할 때 최악의 경우 시간 복잡도는 O(N<sup>2</sup>)이고 파이썬의 기본 정렬 라이브러리는 최악의 경우 시간 복잡도 O(NlogN)을 보장해 상대적으로 빠르다. 


```python
from random import randint
import time

# 배열에 10,000개의 정수를 삽입
array = []
for _ in range(10000):
    array.append(randint(1,100)) # 1부터 100 사이의 랜덤한 정수

# 선택 정렬 프로그램 성능 측정
start_time = time.time()

# 선택 정렬 프로그램 소스 코드
for i in range(len(array)):
    min_index = i # 가장 작은 원소의 인덱스
    for j in range(i+1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
    array[i], array[min_index] = array[min_index], array[i] # 스와프


end_time = time.time() # 측정 종료
print("선택 정렬 성능 측정:", end_time - start_time) # 수행 시간 출력


# 배열 다시 무작위 데이터로 초기화
array = []
for _ in range(10000):
    array.append(randint(1,100)) 

# 기본 정렬 라이브러리 성능 측정
start_time = time.time()

# 기본 정렬 라이브러리 사용
array.sort()


end_time = time.time() # 측정 종료
print("기본 정렬 라이브러리 성능 측정:", end_time - start_time) # 수행 시간 출력



```

컴퓨터의 성능에 따라 결과는 다르게 나오겠지만 기본 정렬 라이브러리가 더 짧게 걸린다.
이렇게 자신이 설계한 알고리즘의 성능을 실제로 확인하기 위해 시간 측정 라이브러리를 사용해보는 습관을 기르는 것이 좋다.

코딩 테스트에서 문제 풀 때는 가동성을 해치지 않는 선에서 최대한 복잡도가 낮게 프로그램을 작성해야 한다.

앞으로 이 책에서 별다른 언급이 없다면 복잡도는 시간 복잡도를 의미한다.